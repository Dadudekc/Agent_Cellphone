#!/usr/bin/env python3
"""
Collaborative Task Manager - Handles multi-agent collaborative tasks

This module manages the new collaborative tasks generated by the FSM system:
1. Collaborative decision-making algorithms
2. Unified knowledge management system
3. Automated collaboration tools
4. Collaborative learning systems
"""

import json
import logging
import time
from dataclasses import dataclass, asdict
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Optional, Any, Set
from enum import Enum
import uuid

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class CollaborativeTaskType(Enum):
    """Types of collaborative tasks"""
    DECISION_MAKING = "decision_making"
    KNOWLEDGE_MANAGEMENT = "knowledge_management"
    COLLABORATION_TOOLS = "collaboration_tools"
    LEARNING_SYSTEMS = "learning_systems"

class CollaborativeTaskState(Enum):
    """States of collaborative tasks"""
    NEW = "new"
    PLANNING = "planning"
    EXECUTION = "execution"
    COLLABORATION = "collaboration"
    REVIEW = "review"
    COMPLETED = "completed"
    FAILED = "failed"

@dataclass
class CollaborativeTask:
    """Collaborative task data structure"""
    id: str
    title: str
    description: str
    task_type: CollaborativeTaskType
    state: CollaborativeTaskState
    created_at: str
    updated_at: str
    assigned_agents: List[str]
    dependencies: List[str] = None
    evidence: List[Dict[str, Any]] = None
    metadata: Dict[str, Any] = None
    collaboration_rounds: int = 0
    current_round: int = 1
    
    def __post_init__(self):
        if self.dependencies is None:
            self.dependencies = []
        if self.evidence is None:
            self.evidence = []
        if self.metadata is None:
            self.metadata = {}

@dataclass
class AgentContribution:
    """Individual agent contribution to collaborative task"""
    agent_id: str
    task_id: str
    round_number: int
    contribution_type: str  # "planning", "execution", "review", "feedback"
    content: str
    timestamp: str
    metadata: Dict[str, Any] = None
    
    def __post_init__(self):
        if self.metadata is None:
            self.metadata = {}

class CollaborativeTaskManager:
    """Manages collaborative tasks across all agents"""
    
    def __init__(self, base_path: Path):
        """
        Initialize Collaborative Task Manager
        
        Args:
            base_path: Base directory for collaborative task data
        """
        self.base_path = Path(base_path)
        self.collaborative_tasks_dir = self.base_path / "collaborative_tasks"
        self.contributions_dir = self.base_path / "contributions"
        self.knowledge_base_dir = self.base_path / "knowledge_base"
        
        # Create necessary directories
        self.collaborative_tasks_dir.mkdir(parents=True, exist_ok=True)
        self.contributions_dir.mkdir(parents=True, exist_ok=True)
        self.knowledge_base_dir.mkdir(parents=True, exist_ok=True)
        
        # Task cache
        self._task_cache: Dict[str, CollaborativeTask] = {}
        self._contribution_cache: Dict[str, List[AgentContribution]] = {}
        
        logger.info(f"Collaborative Task Manager initialized: {self.base_path}")

    def create_collaborative_task(
        self,
        title: str,
        description: str,
        task_type: CollaborativeTaskType,
        assigned_agents: List[str],
        dependencies: List[str] = None
    ) -> CollaborativeTask:
        """Create a new collaborative task"""
        task_id = str(uuid.uuid4())
        now = datetime.now().isoformat()
        
        task = CollaborativeTask(
            id=task_id,
            title=title,
            description=description,
            task_type=task_type,
            state=CollaborativeTaskState.NEW,
            created_at=now,
            updated_at=now,
            assigned_agents=assigned_agents,
            dependencies=dependencies or []
        )
        
        # Save task
        self._save_task(task)
        self._task_cache[task_id] = task
        
        logger.info(f"Created collaborative task: {title} (ID: {task_id})")
        return task

    def get_collaborative_tasks(
        self,
        state: Optional[CollaborativeTaskState] = None,
        task_type: Optional[CollaborativeTaskType] = None
    ) -> List[CollaborativeTask]:
        """Get collaborative tasks with optional filtering"""
        tasks = list(self._task_cache.values())
        
        if state:
            tasks = [t for t in tasks if t.state == state]
        if task_type:
            tasks = [t for t in tasks if t.task_type == task_type]
            
        return tasks

    def add_agent_contribution(
        self,
        task_id: str,
        agent_id: str,
        contribution_type: str,
        content: str,
        round_number: int = None
    ) -> AgentContribution:
        """Add an agent contribution to a collaborative task"""
        if task_id not in self._task_cache:
            raise ValueError(f"Task {task_id} not found")
            
        task = self._task_cache[task_id]
        
        if round_number is None:
            round_number = task.current_round
            
        contribution = AgentContribution(
            agent_id=agent_id,
            task_id=task_id,
            round_number=round_number,
            contribution_type=contribution_type,
            content=content,
            timestamp=datetime.now().isoformat()
        )
        
        # Save contribution
        self._save_contribution(contribution)
        
        # Update task state if needed
        self._update_task_state(task, contribution)
        
        logger.info(f"Added contribution from {agent_id} to task {task_id}")
        return contribution

    def advance_collaboration_round(self, task_id: str) -> bool:
        """Advance to the next collaboration round"""
        if task_id not in self._task_cache:
            return False
            
        task = self._task_cache[task_id]
        task.current_round += 1
        task.collaboration_rounds += 1
        task.updated_at = datetime.now().isoformat()
        
        # Update state based on round
        if task.current_round == 1:
            task.state = CollaborativeTaskState.PLANNING
        elif task.current_round == 2:
            task.state = CollaborativeTaskState.EXECUTION
        elif task.current_round == 3:
            task.state = CollaborativeTaskState.COLLABORATION
        elif task.current_round >= 4:
            task.state = CollaborativeTaskState.REVIEW
            
        self._save_task(task)
        logger.info(f"Advanced task {task_id} to round {task.current_round}")
        return True

    def complete_collaborative_task(self, task_id: str, evidence: str) -> bool:
        """Mark a collaborative task as completed"""
        if task_id not in self._task_cache:
            return False
            
        task = self._task_cache[task_id]
        task.state = CollaborativeTaskState.COMPLETED
        task.updated_at = datetime.now().isoformat()
        task.evidence.append({
            "type": "completion",
            "content": evidence,
            "timestamp": datetime.now().isoformat()
        })
        
        self._save_task(task)
        logger.info(f"Completed collaborative task: {task.title}")
        return True

    def _save_task(self, task: CollaborativeTask) -> None:
        """Save task to disk"""
        task_file = self.collaborative_tasks_dir / f"{task.id}.json"
        with open(task_file, 'w') as f:
            json.dump(asdict(task), f, indent=2, default=str)

    def _save_contribution(self, contribution: AgentContribution) -> None:
        """Save contribution to disk"""
        contribution_file = self.contributions_dir / f"{contribution.task_id}_{contribution.agent_id}_{contribution.round_number}.json"
        with open(contribution_file, 'w') as f:
            json.dump(asdict(contribution), f, indent=2, default=str)

    def _update_task_state(self, task: CollaborativeTask, contribution: AgentContribution) -> None:
        """Update task state based on contribution"""
        # Simple state machine logic
        if task.state == CollaborativeTaskState.NEW and contribution.contribution_type == "planning":
            task.state = CollaborativeTaskState.PLANNING
        elif task.state == CollaborativeTaskState.PLANNING and contribution.contribution_type == "execution":
            task.state = CollaborativeTaskState.EXECUTION
        elif task.state == CollaborativeTaskState.EXECUTION and contribution.contribution_type == "collaboration":
            task.state = CollaborativeTaskState.COLLABORATION
            
        task.updated_at = datetime.now().isoformat()
        self._save_task(task)

    def load_existing_tasks(self) -> None:
        """Load existing tasks from disk"""
        for task_file in self.collaborative_tasks_dir.glob("*.json"):
            try:
                with open(task_file, 'r') as f:
                    task_data = json.load(f)
                    task = CollaborativeTask(**task_data)
                    self._task_cache[task.id] = task
            except Exception as e:
                logger.error(f"Error loading task {task_file}: {e}")

    def get_task_summary(self) -> Dict[str, Any]:
        """Get summary of all collaborative tasks"""
        tasks = list(self._task_cache.values())
        
        return {
            "total_tasks": len(tasks),
            "tasks_by_state": {
                state.value: len([t for t in tasks if t.state == state])
                for state in CollaborativeTaskState
            },
            "tasks_by_type": {
                task_type.value: len([t for t in tasks if t.task_type == task_type])
                for task_type in CollaborativeTaskType
            },
            "active_collaborations": len([t for t in tasks if t.state not in [
                CollaborativeTaskState.COMPLETED, CollaborativeTaskState.FAILED
            ]])
        }
